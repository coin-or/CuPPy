<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>coinor.cuppy.cuttingPlanes API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>coinor.cuppy.cuttingPlanes</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import division
from __future__ import print_function
from __future__ import absolute_import
from builtins import range
from past.utils import old_div
__version__    = &#39;0.5.2&#39;
__author__     = &#39;Aykut Bulut and Ted Ralphs&#39;
__license__    = &#39;Eclipse Public License&#39;
__maintainer__ = &#39;Ted Ralphs&#39;
__email__      = &#39;ted@lehigh.edu&#39;
__url__        = &#39;https://github.com/tkralphs/CuPPy&#39;

import sys
from math import floor
import numpy as np
from cylp.py.utils.sparseUtil import csc_matrixPlus 
from cylp.cy import CyClpSimplex
from cylp.py.modeling import CyLPArray, CyLPModel
PYOMO_INSTALLED = True
try:
    from pyomo.environ import AbstractModel, Var, Constraint, SolverFactory
    from pyomo.environ import NonNegativeReals, NonPositiveReals, Reals, Set
    from pyomo.environ import Integers, Objective, minimize, value
except ImportError:
    PYOMO_INSTALLED = False

DISPLAY_ENABLED = True
try:
    from src.grumpy.polyhedron2D import Polyhedron2D, Figure
    from src.cuppy.milpInstance import MILPInstance
except ImportError:
    try:
        from coinor.grumpy.polyhedron2D import Polyhedron2D, Figure
        from coinor.cuppy.milpInstance import MILPInstance
    except ImportError:
        DISPLAY_ENABLED = False

sys.path.append(&#39;examples&#39;)

EPS = 5

def isInt(x, eps = EPS):
    &#39;&#39;&#39;
    Return True if x is an integer, or if x is a numpy array
    with all integer elements, False otherwise
    &#39;&#39;&#39;
    if isinstance(x, (int, float)):
        return abs(floor(x + 10**(-eps)) - x) &lt; 10**(-eps)
    return (np.abs(np.around(x) - x) &lt; 10**(-eps)).all()

def getFraction(x, eps = EPS):
    &#39;Return the fraction part of x: x - floor(x)&#39;
#    return x - floor(x)
    return np.around(x, decimals = eps) - floor(np.around(x, decimals = eps))

def gomoryMixedIntegerCut(m, rowInds = None, eps = EPS, debug_print = False):
    &#39;&#39;&#39;Return the Gomory mixed integer cut of rows in ``rowInds`` of lp 
    (a CyClpSimplex object)&#39;&#39;&#39;

    cuts = []
    lp = m.lp
    sol = lp.primalVariableSolution[&#39;x&#39;]
    if rowInds is None:
        rowInds = list(range(lp.nConstraints))
    for row in rowInds:
        basicVarInd = lp.basicVariables[row]
        if (basicVarInd in m.integerIndices) and (not isInt(sol[basicVarInd], eps)):
            f0 = getFraction(sol[basicVarInd], eps)
            f = []
            for i in range(lp.nVariables):
                if i in lp.basicVariables:
                    #This is to try to avoid getting very small numbers that 
                    #should be zero
                    f.append(0)
                else:
                    f.append(getFraction(lp.tableau[row, i], eps))
            pi = np.array([old_div(f[j],f0) if f[j] &lt;= f0 
                           else old_div((1-f[j]),(1-f0)) for j in range(lp.nVariables)])
            pi_slacks = np.array([old_div(x,f0) if x &gt; 0 else old_div(-x,(1-f0))  
                                 for x in lp.tableau[row, lp.nVariables:]])
            pi -= pi_slacks * lp.coefMatrix
            pi0 = (1 - np.dot(pi_slacks, lp.constraintsUpper) if m.sense == &#39;&lt;=&#39;
                   else 1 + np.dot(pi_slacks, lp.constraintsUpper))
            if m.sense == &#39;&gt;=&#39;:
                cuts.append((pi, pi0))
            else:
                cuts.append((-pi, -pi0))
    return cuts, []

def liftAndProject(m, rowInds = None, eps = EPS, debug_print = False):
    &#39;&#39;&#39;Return the lift-and-project associated with variables that are basic in 
    rows in ``rowInds`` of lp (a CyClpSimplex object)&#39;&#39;&#39;

    cuts = []
    lp = m.lp
    sol = lp.primalVariableSolution[&#39;x&#39;]
    if rowInds is None:
        rowInds = list(range(lp.nConstraints))
    for row in rowInds:
        basicVarInd = lp.basicVariables[row]
        if (basicVarInd in m.integerIndices) and (not isInt(sol[basicVarInd], eps)): 
            e = np.zeros(lp.nCols)
            e[basicVarInd] = 1
            #Call function for solving CGLP for the associated variable
            #disjunction (disjunction is &#34;&lt;=&#34;) 
            cuts += disjunctionToCut(m, e, floor(sol[basicVarInd]), eps = eps,
                                     debug_print = debug_print)
    return cuts, []
            
def disjunctionToCut(m, pi, pi0, debug_print = False, use_cylp = True, eps = EPS):
    &#39;&#39;&#39;Generate the most violated valid inequality from a given disjunction&#39;&#39;&#39;
    me = &#34;cglp_cuts: &#34;
    lp = m.lp
    sol = lp.primalVariableSolution[&#39;x&#39;]

    if debug_print:
        print(me, &#34;constraints sense = &#34;, m.sense)
        print(me, &#34;matrix = &#34;)
        print(m.A)
        print(me, &#34;rhs = &#34;, m.b)
        print(me, &#34;vars lower bounds = &#34;, lp.variablesLower)
        print(me, &#34;vars upper bounds = &#34;, lp.variablesUpper)
        print(me, &#34;objective = &#34;, lp.objective)
        print(me, &#34;current solution = &#34;, sol)
        print(me, &#34;pi = &#34;, pi)
        print(me, &#34;pi0 = &#34;, pi0)

    ############################################################################
    ## There are two given LPs:
    ## s.t. Ax &gt;= b           s.t. Ax &gt;= b
    ##   -pi.x &gt;= -pi_0          pi.x &gt;= pi_0+1
    ## A, b, c, pi, pi_0 are given
    ##
    ## CGLP: alpha.x &gt;= beta should be valid for both LPs above
    ##
    ## min alpha.x* - beta
    ## uA - u0.pi = alpha
    ## vA + v0.pi = alpha
    ## ub - u0.pi_0 &gt;= beta 
    ## vb + v0.(pi_0 + 1) &gt;= beta 
    ## u0 + v0 = 1
    ## u, v, u0, v0 &gt;= 0
    ## if min value comes out &lt; 0, then (alpha.x &gt;= beta) is a cut.
    ############################################################################

    pi = CyLPArray(pi)
    
    Atran = m.A.transpose()
    b = CyLPArray(m.b)
    numRows, numCols = m.A.shape
    
    if use_cylp:
        sp = CyLPModel()
        u = sp.addVariable(&#39;u&#39;, numRows, isInt = False)
        v = sp.addVariable(&#39;v&#39;, numRows, isInt = False)
        u0 = sp.addVariable(&#39;u0&#39;, 1, isInt = False)
        v0 = sp.addVariable(&#39;v0&#39;, 1, isInt = False)
        alpha = sp.addVariable(&#39;alpha&#39;, lp.nVariables, isInt = False)
        beta = sp.addVariable(&#39;beta&#39;, 1, isInt = False)
        
        #This should be as simple as this, but it doesn&#39;t work.
        #Maybe a bug in CyLP? 
        #sp += alpha - Atran*u - pi*u0 == 0
        #sp += alpha - Atran*v + pi*v0 == 0
        for i in range(numCols):
            sp += alpha[i] - sum(Atran[i,j]*u[j] for j in range(numRows)) - pi[i]*u0 == 0
        for i in range(numCols):
            sp += alpha[i] - sum(Atran[i,j]*v[j] for j in range(numRows)) + pi[i]*v0 == 0
        if m.sense == &#39;&lt;=&#39;:
            sp += beta - b*u - pi0*u0 &gt;= 0
            sp += beta - b*v + (pi0 + 1)*v0 &gt;= 0
        else:
            sp += beta - b*u - pi0*u0 &lt;= 0
            sp += beta - b*v + (pi0 + 1)*v0 &lt;= 0
        sp += u0 + v0 == 1
        sp += u &gt;= 0
        sp += v &gt;= 0
        sp += u0 &gt;= 0
        sp += v0 &gt;= 0
        if m.sense == &#39;&lt;=&#39;:
            sp.objective = sum(-sol[i]*alpha[i] for i in range(numCols)) + beta
        else:
            #This direction is not debugged
            sp.objective = sum(sol[i]*alpha[i] for i in range(numCols)) - beta            

        cglp = CyClpSimplex(sp)
        # If we want to solve it as an MILP
        # cglp = CyClpSimplex(sp).getCbcModel()
        #cglp.writeLp(&#39;lp.lp&#39;)
        cglp.logLevel = 0
        cglp.primal(startFinishOptions = &#39;x&#39;)
        # Solve as MILP
        # cglp.solve()
        beta = cglp.primalVariableSolution[&#39;beta&#39;][0]
        alpha = cglp.primalVariableSolution[&#39;alpha&#39;]
        u = cglp.primalVariableSolution[&#39;u&#39;]
        v = cglp.primalVariableSolution[&#39;v&#39;]
        u0 = cglp.primalVariableSolution[&#39;u0&#39;][0]
        v0 = cglp.primalVariableSolution[&#39;v0&#39;][0]
        if debug_print:
            print(me, &#39;Objective Value: &#39;, cglp.objectiveValue)

        if debug_print:
            print(me, &#39;u: &#39;, u)
            print(me, &#39;v: &#39;, v)
            print(me, &#39;u0: &#39;, u0)
            print(me, &#39;v0: &#39;, v0)
    else: 
        CG = AbstractModel()
        CG.u = Var(list(range(numRows)), domain=NonNegativeReals,
                   bounds = (0.0, None))
        CG.v = Var(list(range(numRows)), domain=NonNegativeReals,
                   bounds = (0.0, None))
        CG.u0 = Var(domain=NonNegativeReals, bounds = (0.0, None))
        CG.v0 = Var(domain=NonNegativeReals, bounds = (0.0, None))
        CG.alpha = Var(list(range(numRows)), domain=Reals,
                       bounds = (None, None))    
        CG.beta  = Var(domain=Reals, bounds = (None, None))    
        
        ## Constraints
        def pi_rule_left(CG, i):
            x = float(pi[i])
            return(sum(Atran[i, j]*CG.u[j] for j in range(numRows)) -
                   x*CG.u0 - CG.alpha[i] == 0.0)
        CG.pi_rule_left = Constraint(list(range(numCols)), rule=pi_rule_left)
        
        def pi_rule_right(CG, i):
            x = float(pi[i])
            return(sum(Atran[i, j]*CG.v[j] for j in range(numRows)) +
                   x*CG.v0 - CG.alpha[i] == 0.0)
        CG.pi_rule_right = Constraint(list(range(numCols)), rule=pi_rule_right)

        if m.sense == &#39;&lt;=&#39;:
            def pi0_rule_left(CG):
                return(sum(b[j]*CG.u[j] for j in range(numRows)) -
                       pi0*CG.u0 - CG.beta &lt;= 0.0)
            CG.pi0_rule_left = Constraint(rule=pi0_rule_left)
            
            def pi0_rule_right(CG):
                return(sum(b[j]*CG.v[j] for j in range(numRows)) +
                       (pi0 + 1)*CG.v0 - CG.beta &lt;= 0.0)
            CG.pi0_rule_right = Constraint(rule=pi0_rule_right)
        else:
            def pi0_rule_left(CG):
                return(sum(b[j]*CG.u[j] for j in range(numRows)) -
                       pi0*CG.u0 - CG.beta &gt;= 0.0)
            CG.pi0_rule_left = Constraint(rule=pi0_rule_left)
            
            def pi0_rule_right(CG):
                return(sum(b[j]*CG.v[j] for j in range(numRows)) +
                       (pi0 + 1)*CG.v0 - CG.beta &gt;= 0.0)
            CG.pi0_rule_right = Constraint(rule=pi0_rule_right)

        def normalization_rule(CG):
            return(CG.u0 + CG.v0 == 1.0)
        CG.normalization_rule = Constraint(rule=normalization_rule)
        
        def objective_rule(CG):
            return(sum(sol[i]*CG.alpha[i] for i in range(numCols)) -
                   CG.beta)
        if m.sense == &#39;&lt;=&#39;:
            CG.objective = Objective(sense=maximize, rule=objective_rule)
        else:
            CG.objective = Objective(sense=minimize, rule=objective_rule)
        
        opt = SolverFactory(&#34;cbc&#34;)
        instance = CG.create_instance()
        #instance.pprint()
        #instance.write(&#34;foo.nl&#34;, format = &#34;nl&#34;)
        #opt.options[&#39;bonmin.bb_log_level&#39;] = 5
        #opt.options[&#39;bonmin.bb_log_interval&#39;] = 1
        results = opt.solve(instance, tee=False)
        #results = opt.solve(instance)
        instance.solutions.load_from(results)
        
        beta = instance.beta.value
        alpha = np.array([instance.alpha[i].value
                          for i in range(lp.nVariables)])
        
    violation =  beta - np.dot(alpha, sol) 
    if debug_print:
        print(me, &#39;Beta: &#39;, beta)
        print(me, &#39;alpha: &#39;, alpha)
        print(me, &#39;Violation of cut: &#39;, violation)

    
    if np.abs(violation) &gt; 10**(-eps):
        return [(alpha, beta)]

    print(&#39;No violated cuts found solving CGLP&#39;, violation)
    return []

def disp_relaxation(f, A, b, cuts = [], sol = None, disj = [], filename = None):
    #TODO: Check sense of inequalities by looking explicitly at
    #      lp.constraintsUpper and lp.constraintsLower
    p = Polyhedron2D(A = A, b = b)
    f.add_polyhedron(p, label = &#39;Polyhedron $P$&#39;)
    f.set_xlim(p.xlim)
    f.set_ylim(p.ylim)
    pI = p.make_integer_hull()
    f.add_polyhedron(pI, show_int_points = True, color = &#39;red&#39;,
                     linestyle = &#39;dashed&#39;,
                     label = &#39;Convex hull of integer points&#39;)
    for (coeff, r) in cuts:
        f.add_line(coeff, r, p.xlim, p.ylim, color = &#39;green&#39;, linestyle = &#39;dashed&#39;)
    for (coeff, r) in disj:
        f.add_line(coeff, r, p.xlim, p.ylim, color = &#39;red&#39;, linestyle = &#39;dashed&#39;)
        f.add_line(coeff, r+1, p.xlim, p.ylim, color = &#39;red&#39;, linestyle = &#39;dashed&#39;)
    if sol is not None:
        f.add_point(sol, radius = .05)
    f.show(filename = filename)

def solve(m, whichCuts = [], use_cglp = False, debug_print = False, eps = EPS, 
          max_iter = 100, max_cuts = 10, display = False, filename = None):    

    if not isinstance(m, MILPInstance):
        print(&#34;Invalid first parameter: Must be of type MILPInstance&#34;)
        exit

    if not DISPLAY_ENABLED:
        display = False
    else:
        f = Figure()
  
    if m.lp.nCols &gt; 2 or m.A is None:
        display = False
    m.lp.logLevel = 0

    #Include bounds explicitly in the constraint matrix for display and for
    #use in cut generators. 
    infinity = m.lp.getCoinInfinity()
    if m.sense == &#39;&lt;=&#39;:
        b = m.lp.constraintsUpper.copy()
        mult = -1.0
    else:
        b = m.lp.constraintsLower.copy()
        mult = 1.0
    A = m.A.copy()
    for i in range(m.lp.nCols):
        e = np.zeros((1, m.lp.nCols))
        if m.lp.variablesUpper[i] &lt; infinity:
            b.resize(b.size+1, refcheck = False)
            e[0, i] = -mult
            b[-1] = -mult*m.lp.variablesUpper[i]
            A = np.vstack((A, e))
        if m.lp.variablesLower[i] &gt; -infinity:
            b.resize(b.size+1, refcheck = False)
            e[0, i] = mult
            b[-1] = mult*m.lp.variablesLower[i]
            A = np.vstack((A, e))
    m.A = A
    m.b = b

    if display and filename is not None:
        disp_relaxation(f, m.A, m.b, filename = filename+&#39;.png&#39;)
    elif display:
        disp_relaxation(f, m.A, m.b)

    disj = []
    prev_sol = np.zeros((1, m.lp.nCols))
    for i in range(max_iter):
        print(&#39;Iteration &#39;, i)
        m.lp.primal(startFinishOptions = &#39;x&#39;)
        print(&#39;Current bound:&#39;, m.lp.objectiveValue)
        #Binv = np.zeros(shape = (lp.nConstraints, lp.nConstraints))
        #for i in range(lp.nVariables, lp.nVariables+lp.nConstraints):
        #    lp.getBInvACol(i, Binv[i-lp.nVariables,:])
        #rhs = lp.rhs
        if m.sense == &#39;&lt;=&#39;:
            rhs = np.dot(m.lp.basisInverse, m.lp.constraintsUpper)
        else:
            rhs = np.dot(m.lp.basisInverse, m.lp.constraintsLower)
        sol = m.lp.primalVariableSolution[&#39;x&#39;]
        if debug_print:
            print(&#39;Current basis inverse:&#39;)
            print(m.lp.basisInverse)
            print(&#39;Condition number of basis inverse&#39;,
                  np.around(np.linalg.cond(m.lp.basisInverse)))
            print(&#39;Current tableaux:&#39;)
            print(m.lp.tableau)
            print(&#39;Current right hand side:\n&#39;, rhs)
            #print(&#39;Dual solution:&#39;, m.lp.dualConstraintSolution)
            #print lp.rhs
        print(&#39;Current solution: &#39;, sol)

        if (sol - prev_sol).any():
            prev_sol = sol
        else:
            print (&#34;Solution repeated, stalling detected&#34;) 
            print (&#34;Exiting&#34;)
            break

        if isInt(sol[m.integerIndices], eps):
            print(&#39;Integer solution found!&#39;)
            break

        if np.around(np.linalg.cond(m.lp.basisInverse)) &gt;= 10**32:
            print (&#34;Condition number of the basis matrix exceeds 10^32&#34;) 
            print (&#34;Exiting&#34;)
            break

        cuts = []
        if disj == []:
            for (cg, args) in whichCuts:
                tmp_cuts, tmp_disj = cg(m, **args, eps = eps)
                cuts += tmp_cuts
                disj += tmp_disj
        cur_num_cuts = len(cuts)
        if use_cglp:
            if len(disj) &gt; 0:
                for d in disj:
                    cuts += disjunctionToCut(m, d[0], d[1], eps = eps)
        if cuts == []:
            if disj == []:
                print(&#39;No cuts found and terminating!&#39;)
                break
            else:
                print(&#39;No cuts found but continuing!&#39;)
        if display and filename is not None:
            disp_relaxation(f, m.A, m.b, cuts, sol, disj,
                            filename = filename+str(i)+&#39;.png&#39;)
        elif display:
            disp_relaxation(f, m.A, m.b, cuts, sol, disj)
        if len(cuts) == cur_num_cuts:
            disj = []
        for (coeff, r) in cuts[:max_cuts]:
            #TODO sort cuts by degree of violation
            if m.sense == &#39;&lt;=&#39;:
                coeff = np.floor(coeff*(10**eps))/(10**eps)
                r = np.ceil(r*(10**eps))/(10**eps)
                print(&#39;Adding cut: &#39;, coeff, &#39;&lt;=&#39;, r)
                m.lp += CyLPArray(coeff) * m.x &lt;= r
            else:
                coeff = np.ceil(coeff*(10**eps))/(10**eps)
                r = np.floor(r*(10**eps))/(10**eps)
                print(&#39;Adding cut: &#39;, coeff, &#39;&gt;=&#39;, r)
                m.lp += CyLPArray(coeff) * m.x &gt;= r
            m.A = np.vstack((m.A, np.array(coeff)))
            m.b.resize(m.b.size+1, refcheck = False)
            m.b[-1] = r
            
    if display:
        disp_relaxation(f, m.A, m.b)

if __name__ == &#39;__main__&#39;:
            
    solve(MILPInstance(module_name = &#39;coinor.cuppy.examples.MIP6&#39;),
          whichCuts = [(gomoryMixedIntegerCut, {})],
          display = True, debug_print = True, use_cglp = False)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="coinor.cuppy.cuttingPlanes.disjunctionToCut"><code class="name flex">
<span>def <span class="ident">disjunctionToCut</span></span>(<span>m, pi, pi0, debug_print=False, use_cylp=True, eps=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the most violated valid inequality from a given disjunction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disjunctionToCut(m, pi, pi0, debug_print = False, use_cylp = True, eps = EPS):
    &#39;&#39;&#39;Generate the most violated valid inequality from a given disjunction&#39;&#39;&#39;
    me = &#34;cglp_cuts: &#34;
    lp = m.lp
    sol = lp.primalVariableSolution[&#39;x&#39;]

    if debug_print:
        print(me, &#34;constraints sense = &#34;, m.sense)
        print(me, &#34;matrix = &#34;)
        print(m.A)
        print(me, &#34;rhs = &#34;, m.b)
        print(me, &#34;vars lower bounds = &#34;, lp.variablesLower)
        print(me, &#34;vars upper bounds = &#34;, lp.variablesUpper)
        print(me, &#34;objective = &#34;, lp.objective)
        print(me, &#34;current solution = &#34;, sol)
        print(me, &#34;pi = &#34;, pi)
        print(me, &#34;pi0 = &#34;, pi0)

    ############################################################################
    ## There are two given LPs:
    ## s.t. Ax &gt;= b           s.t. Ax &gt;= b
    ##   -pi.x &gt;= -pi_0          pi.x &gt;= pi_0+1
    ## A, b, c, pi, pi_0 are given
    ##
    ## CGLP: alpha.x &gt;= beta should be valid for both LPs above
    ##
    ## min alpha.x* - beta
    ## uA - u0.pi = alpha
    ## vA + v0.pi = alpha
    ## ub - u0.pi_0 &gt;= beta 
    ## vb + v0.(pi_0 + 1) &gt;= beta 
    ## u0 + v0 = 1
    ## u, v, u0, v0 &gt;= 0
    ## if min value comes out &lt; 0, then (alpha.x &gt;= beta) is a cut.
    ############################################################################

    pi = CyLPArray(pi)
    
    Atran = m.A.transpose()
    b = CyLPArray(m.b)
    numRows, numCols = m.A.shape
    
    if use_cylp:
        sp = CyLPModel()
        u = sp.addVariable(&#39;u&#39;, numRows, isInt = False)
        v = sp.addVariable(&#39;v&#39;, numRows, isInt = False)
        u0 = sp.addVariable(&#39;u0&#39;, 1, isInt = False)
        v0 = sp.addVariable(&#39;v0&#39;, 1, isInt = False)
        alpha = sp.addVariable(&#39;alpha&#39;, lp.nVariables, isInt = False)
        beta = sp.addVariable(&#39;beta&#39;, 1, isInt = False)
        
        #This should be as simple as this, but it doesn&#39;t work.
        #Maybe a bug in CyLP? 
        #sp += alpha - Atran*u - pi*u0 == 0
        #sp += alpha - Atran*v + pi*v0 == 0
        for i in range(numCols):
            sp += alpha[i] - sum(Atran[i,j]*u[j] for j in range(numRows)) - pi[i]*u0 == 0
        for i in range(numCols):
            sp += alpha[i] - sum(Atran[i,j]*v[j] for j in range(numRows)) + pi[i]*v0 == 0
        if m.sense == &#39;&lt;=&#39;:
            sp += beta - b*u - pi0*u0 &gt;= 0
            sp += beta - b*v + (pi0 + 1)*v0 &gt;= 0
        else:
            sp += beta - b*u - pi0*u0 &lt;= 0
            sp += beta - b*v + (pi0 + 1)*v0 &lt;= 0
        sp += u0 + v0 == 1
        sp += u &gt;= 0
        sp += v &gt;= 0
        sp += u0 &gt;= 0
        sp += v0 &gt;= 0
        if m.sense == &#39;&lt;=&#39;:
            sp.objective = sum(-sol[i]*alpha[i] for i in range(numCols)) + beta
        else:
            #This direction is not debugged
            sp.objective = sum(sol[i]*alpha[i] for i in range(numCols)) - beta            

        cglp = CyClpSimplex(sp)
        # If we want to solve it as an MILP
        # cglp = CyClpSimplex(sp).getCbcModel()
        #cglp.writeLp(&#39;lp.lp&#39;)
        cglp.logLevel = 0
        cglp.primal(startFinishOptions = &#39;x&#39;)
        # Solve as MILP
        # cglp.solve()
        beta = cglp.primalVariableSolution[&#39;beta&#39;][0]
        alpha = cglp.primalVariableSolution[&#39;alpha&#39;]
        u = cglp.primalVariableSolution[&#39;u&#39;]
        v = cglp.primalVariableSolution[&#39;v&#39;]
        u0 = cglp.primalVariableSolution[&#39;u0&#39;][0]
        v0 = cglp.primalVariableSolution[&#39;v0&#39;][0]
        if debug_print:
            print(me, &#39;Objective Value: &#39;, cglp.objectiveValue)

        if debug_print:
            print(me, &#39;u: &#39;, u)
            print(me, &#39;v: &#39;, v)
            print(me, &#39;u0: &#39;, u0)
            print(me, &#39;v0: &#39;, v0)
    else: 
        CG = AbstractModel()
        CG.u = Var(list(range(numRows)), domain=NonNegativeReals,
                   bounds = (0.0, None))
        CG.v = Var(list(range(numRows)), domain=NonNegativeReals,
                   bounds = (0.0, None))
        CG.u0 = Var(domain=NonNegativeReals, bounds = (0.0, None))
        CG.v0 = Var(domain=NonNegativeReals, bounds = (0.0, None))
        CG.alpha = Var(list(range(numRows)), domain=Reals,
                       bounds = (None, None))    
        CG.beta  = Var(domain=Reals, bounds = (None, None))    
        
        ## Constraints
        def pi_rule_left(CG, i):
            x = float(pi[i])
            return(sum(Atran[i, j]*CG.u[j] for j in range(numRows)) -
                   x*CG.u0 - CG.alpha[i] == 0.0)
        CG.pi_rule_left = Constraint(list(range(numCols)), rule=pi_rule_left)
        
        def pi_rule_right(CG, i):
            x = float(pi[i])
            return(sum(Atran[i, j]*CG.v[j] for j in range(numRows)) +
                   x*CG.v0 - CG.alpha[i] == 0.0)
        CG.pi_rule_right = Constraint(list(range(numCols)), rule=pi_rule_right)

        if m.sense == &#39;&lt;=&#39;:
            def pi0_rule_left(CG):
                return(sum(b[j]*CG.u[j] for j in range(numRows)) -
                       pi0*CG.u0 - CG.beta &lt;= 0.0)
            CG.pi0_rule_left = Constraint(rule=pi0_rule_left)
            
            def pi0_rule_right(CG):
                return(sum(b[j]*CG.v[j] for j in range(numRows)) +
                       (pi0 + 1)*CG.v0 - CG.beta &lt;= 0.0)
            CG.pi0_rule_right = Constraint(rule=pi0_rule_right)
        else:
            def pi0_rule_left(CG):
                return(sum(b[j]*CG.u[j] for j in range(numRows)) -
                       pi0*CG.u0 - CG.beta &gt;= 0.0)
            CG.pi0_rule_left = Constraint(rule=pi0_rule_left)
            
            def pi0_rule_right(CG):
                return(sum(b[j]*CG.v[j] for j in range(numRows)) +
                       (pi0 + 1)*CG.v0 - CG.beta &gt;= 0.0)
            CG.pi0_rule_right = Constraint(rule=pi0_rule_right)

        def normalization_rule(CG):
            return(CG.u0 + CG.v0 == 1.0)
        CG.normalization_rule = Constraint(rule=normalization_rule)
        
        def objective_rule(CG):
            return(sum(sol[i]*CG.alpha[i] for i in range(numCols)) -
                   CG.beta)
        if m.sense == &#39;&lt;=&#39;:
            CG.objective = Objective(sense=maximize, rule=objective_rule)
        else:
            CG.objective = Objective(sense=minimize, rule=objective_rule)
        
        opt = SolverFactory(&#34;cbc&#34;)
        instance = CG.create_instance()
        #instance.pprint()
        #instance.write(&#34;foo.nl&#34;, format = &#34;nl&#34;)
        #opt.options[&#39;bonmin.bb_log_level&#39;] = 5
        #opt.options[&#39;bonmin.bb_log_interval&#39;] = 1
        results = opt.solve(instance, tee=False)
        #results = opt.solve(instance)
        instance.solutions.load_from(results)
        
        beta = instance.beta.value
        alpha = np.array([instance.alpha[i].value
                          for i in range(lp.nVariables)])
        
    violation =  beta - np.dot(alpha, sol) 
    if debug_print:
        print(me, &#39;Beta: &#39;, beta)
        print(me, &#39;alpha: &#39;, alpha)
        print(me, &#39;Violation of cut: &#39;, violation)

    
    if np.abs(violation) &gt; 10**(-eps):
        return [(alpha, beta)]

    print(&#39;No violated cuts found solving CGLP&#39;, violation)
    return []</code></pre>
</details>
</dd>
<dt id="coinor.cuppy.cuttingPlanes.disp_relaxation"><code class="name flex">
<span>def <span class="ident">disp_relaxation</span></span>(<span>f, A, b, cuts=[], sol=None, disj=[], filename=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disp_relaxation(f, A, b, cuts = [], sol = None, disj = [], filename = None):
    #TODO: Check sense of inequalities by looking explicitly at
    #      lp.constraintsUpper and lp.constraintsLower
    p = Polyhedron2D(A = A, b = b)
    f.add_polyhedron(p, label = &#39;Polyhedron $P$&#39;)
    f.set_xlim(p.xlim)
    f.set_ylim(p.ylim)
    pI = p.make_integer_hull()
    f.add_polyhedron(pI, show_int_points = True, color = &#39;red&#39;,
                     linestyle = &#39;dashed&#39;,
                     label = &#39;Convex hull of integer points&#39;)
    for (coeff, r) in cuts:
        f.add_line(coeff, r, p.xlim, p.ylim, color = &#39;green&#39;, linestyle = &#39;dashed&#39;)
    for (coeff, r) in disj:
        f.add_line(coeff, r, p.xlim, p.ylim, color = &#39;red&#39;, linestyle = &#39;dashed&#39;)
        f.add_line(coeff, r+1, p.xlim, p.ylim, color = &#39;red&#39;, linestyle = &#39;dashed&#39;)
    if sol is not None:
        f.add_point(sol, radius = .05)
    f.show(filename = filename)</code></pre>
</details>
</dd>
<dt id="coinor.cuppy.cuttingPlanes.getFraction"><code class="name flex">
<span>def <span class="ident">getFraction</span></span>(<span>x, eps=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the fraction part of x: x - floor(x)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getFraction(x, eps = EPS):
    &#39;Return the fraction part of x: x - floor(x)&#39;
#    return x - floor(x)
    return np.around(x, decimals = eps) - floor(np.around(x, decimals = eps))</code></pre>
</details>
</dd>
<dt id="coinor.cuppy.cuttingPlanes.gomoryMixedIntegerCut"><code class="name flex">
<span>def <span class="ident">gomoryMixedIntegerCut</span></span>(<span>m, rowInds=None, eps=5, debug_print=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the Gomory mixed integer cut of rows in <code>rowInds</code> of lp
(a CyClpSimplex object)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gomoryMixedIntegerCut(m, rowInds = None, eps = EPS, debug_print = False):
    &#39;&#39;&#39;Return the Gomory mixed integer cut of rows in ``rowInds`` of lp 
    (a CyClpSimplex object)&#39;&#39;&#39;

    cuts = []
    lp = m.lp
    sol = lp.primalVariableSolution[&#39;x&#39;]
    if rowInds is None:
        rowInds = list(range(lp.nConstraints))
    for row in rowInds:
        basicVarInd = lp.basicVariables[row]
        if (basicVarInd in m.integerIndices) and (not isInt(sol[basicVarInd], eps)):
            f0 = getFraction(sol[basicVarInd], eps)
            f = []
            for i in range(lp.nVariables):
                if i in lp.basicVariables:
                    #This is to try to avoid getting very small numbers that 
                    #should be zero
                    f.append(0)
                else:
                    f.append(getFraction(lp.tableau[row, i], eps))
            pi = np.array([old_div(f[j],f0) if f[j] &lt;= f0 
                           else old_div((1-f[j]),(1-f0)) for j in range(lp.nVariables)])
            pi_slacks = np.array([old_div(x,f0) if x &gt; 0 else old_div(-x,(1-f0))  
                                 for x in lp.tableau[row, lp.nVariables:]])
            pi -= pi_slacks * lp.coefMatrix
            pi0 = (1 - np.dot(pi_slacks, lp.constraintsUpper) if m.sense == &#39;&lt;=&#39;
                   else 1 + np.dot(pi_slacks, lp.constraintsUpper))
            if m.sense == &#39;&gt;=&#39;:
                cuts.append((pi, pi0))
            else:
                cuts.append((-pi, -pi0))
    return cuts, []</code></pre>
</details>
</dd>
<dt id="coinor.cuppy.cuttingPlanes.isInt"><code class="name flex">
<span>def <span class="ident">isInt</span></span>(<span>x, eps=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if x is an integer, or if x is a numpy array
with all integer elements, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isInt(x, eps = EPS):
    &#39;&#39;&#39;
    Return True if x is an integer, or if x is a numpy array
    with all integer elements, False otherwise
    &#39;&#39;&#39;
    if isinstance(x, (int, float)):
        return abs(floor(x + 10**(-eps)) - x) &lt; 10**(-eps)
    return (np.abs(np.around(x) - x) &lt; 10**(-eps)).all()</code></pre>
</details>
</dd>
<dt id="coinor.cuppy.cuttingPlanes.liftAndProject"><code class="name flex">
<span>def <span class="ident">liftAndProject</span></span>(<span>m, rowInds=None, eps=5, debug_print=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the lift-and-project associated with variables that are basic in
rows in <code>rowInds</code> of lp (a CyClpSimplex object)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def liftAndProject(m, rowInds = None, eps = EPS, debug_print = False):
    &#39;&#39;&#39;Return the lift-and-project associated with variables that are basic in 
    rows in ``rowInds`` of lp (a CyClpSimplex object)&#39;&#39;&#39;

    cuts = []
    lp = m.lp
    sol = lp.primalVariableSolution[&#39;x&#39;]
    if rowInds is None:
        rowInds = list(range(lp.nConstraints))
    for row in rowInds:
        basicVarInd = lp.basicVariables[row]
        if (basicVarInd in m.integerIndices) and (not isInt(sol[basicVarInd], eps)): 
            e = np.zeros(lp.nCols)
            e[basicVarInd] = 1
            #Call function for solving CGLP for the associated variable
            #disjunction (disjunction is &#34;&lt;=&#34;) 
            cuts += disjunctionToCut(m, e, floor(sol[basicVarInd]), eps = eps,
                                     debug_print = debug_print)
    return cuts, []</code></pre>
</details>
</dd>
<dt id="coinor.cuppy.cuttingPlanes.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>m, whichCuts=[], use_cglp=False, debug_print=False, eps=5, max_iter=100, max_cuts=10, display=False, filename=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve(m, whichCuts = [], use_cglp = False, debug_print = False, eps = EPS, 
          max_iter = 100, max_cuts = 10, display = False, filename = None):    

    if not isinstance(m, MILPInstance):
        print(&#34;Invalid first parameter: Must be of type MILPInstance&#34;)
        exit

    if not DISPLAY_ENABLED:
        display = False
    else:
        f = Figure()
  
    if m.lp.nCols &gt; 2 or m.A is None:
        display = False
    m.lp.logLevel = 0

    #Include bounds explicitly in the constraint matrix for display and for
    #use in cut generators. 
    infinity = m.lp.getCoinInfinity()
    if m.sense == &#39;&lt;=&#39;:
        b = m.lp.constraintsUpper.copy()
        mult = -1.0
    else:
        b = m.lp.constraintsLower.copy()
        mult = 1.0
    A = m.A.copy()
    for i in range(m.lp.nCols):
        e = np.zeros((1, m.lp.nCols))
        if m.lp.variablesUpper[i] &lt; infinity:
            b.resize(b.size+1, refcheck = False)
            e[0, i] = -mult
            b[-1] = -mult*m.lp.variablesUpper[i]
            A = np.vstack((A, e))
        if m.lp.variablesLower[i] &gt; -infinity:
            b.resize(b.size+1, refcheck = False)
            e[0, i] = mult
            b[-1] = mult*m.lp.variablesLower[i]
            A = np.vstack((A, e))
    m.A = A
    m.b = b

    if display and filename is not None:
        disp_relaxation(f, m.A, m.b, filename = filename+&#39;.png&#39;)
    elif display:
        disp_relaxation(f, m.A, m.b)

    disj = []
    prev_sol = np.zeros((1, m.lp.nCols))
    for i in range(max_iter):
        print(&#39;Iteration &#39;, i)
        m.lp.primal(startFinishOptions = &#39;x&#39;)
        print(&#39;Current bound:&#39;, m.lp.objectiveValue)
        #Binv = np.zeros(shape = (lp.nConstraints, lp.nConstraints))
        #for i in range(lp.nVariables, lp.nVariables+lp.nConstraints):
        #    lp.getBInvACol(i, Binv[i-lp.nVariables,:])
        #rhs = lp.rhs
        if m.sense == &#39;&lt;=&#39;:
            rhs = np.dot(m.lp.basisInverse, m.lp.constraintsUpper)
        else:
            rhs = np.dot(m.lp.basisInverse, m.lp.constraintsLower)
        sol = m.lp.primalVariableSolution[&#39;x&#39;]
        if debug_print:
            print(&#39;Current basis inverse:&#39;)
            print(m.lp.basisInverse)
            print(&#39;Condition number of basis inverse&#39;,
                  np.around(np.linalg.cond(m.lp.basisInverse)))
            print(&#39;Current tableaux:&#39;)
            print(m.lp.tableau)
            print(&#39;Current right hand side:\n&#39;, rhs)
            #print(&#39;Dual solution:&#39;, m.lp.dualConstraintSolution)
            #print lp.rhs
        print(&#39;Current solution: &#39;, sol)

        if (sol - prev_sol).any():
            prev_sol = sol
        else:
            print (&#34;Solution repeated, stalling detected&#34;) 
            print (&#34;Exiting&#34;)
            break

        if isInt(sol[m.integerIndices], eps):
            print(&#39;Integer solution found!&#39;)
            break

        if np.around(np.linalg.cond(m.lp.basisInverse)) &gt;= 10**32:
            print (&#34;Condition number of the basis matrix exceeds 10^32&#34;) 
            print (&#34;Exiting&#34;)
            break

        cuts = []
        if disj == []:
            for (cg, args) in whichCuts:
                tmp_cuts, tmp_disj = cg(m, **args, eps = eps)
                cuts += tmp_cuts
                disj += tmp_disj
        cur_num_cuts = len(cuts)
        if use_cglp:
            if len(disj) &gt; 0:
                for d in disj:
                    cuts += disjunctionToCut(m, d[0], d[1], eps = eps)
        if cuts == []:
            if disj == []:
                print(&#39;No cuts found and terminating!&#39;)
                break
            else:
                print(&#39;No cuts found but continuing!&#39;)
        if display and filename is not None:
            disp_relaxation(f, m.A, m.b, cuts, sol, disj,
                            filename = filename+str(i)+&#39;.png&#39;)
        elif display:
            disp_relaxation(f, m.A, m.b, cuts, sol, disj)
        if len(cuts) == cur_num_cuts:
            disj = []
        for (coeff, r) in cuts[:max_cuts]:
            #TODO sort cuts by degree of violation
            if m.sense == &#39;&lt;=&#39;:
                coeff = np.floor(coeff*(10**eps))/(10**eps)
                r = np.ceil(r*(10**eps))/(10**eps)
                print(&#39;Adding cut: &#39;, coeff, &#39;&lt;=&#39;, r)
                m.lp += CyLPArray(coeff) * m.x &lt;= r
            else:
                coeff = np.ceil(coeff*(10**eps))/(10**eps)
                r = np.floor(r*(10**eps))/(10**eps)
                print(&#39;Adding cut: &#39;, coeff, &#39;&gt;=&#39;, r)
                m.lp += CyLPArray(coeff) * m.x &gt;= r
            m.A = np.vstack((m.A, np.array(coeff)))
            m.b.resize(m.b.size+1, refcheck = False)
            m.b[-1] = r
            
    if display:
        disp_relaxation(f, m.A, m.b)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="coinor.cuppy" href="index.html">coinor.cuppy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="coinor.cuppy.cuttingPlanes.disjunctionToCut" href="#coinor.cuppy.cuttingPlanes.disjunctionToCut">disjunctionToCut</a></code></li>
<li><code><a title="coinor.cuppy.cuttingPlanes.disp_relaxation" href="#coinor.cuppy.cuttingPlanes.disp_relaxation">disp_relaxation</a></code></li>
<li><code><a title="coinor.cuppy.cuttingPlanes.getFraction" href="#coinor.cuppy.cuttingPlanes.getFraction">getFraction</a></code></li>
<li><code><a title="coinor.cuppy.cuttingPlanes.gomoryMixedIntegerCut" href="#coinor.cuppy.cuttingPlanes.gomoryMixedIntegerCut">gomoryMixedIntegerCut</a></code></li>
<li><code><a title="coinor.cuppy.cuttingPlanes.isInt" href="#coinor.cuppy.cuttingPlanes.isInt">isInt</a></code></li>
<li><code><a title="coinor.cuppy.cuttingPlanes.liftAndProject" href="#coinor.cuppy.cuttingPlanes.liftAndProject">liftAndProject</a></code></li>
<li><code><a title="coinor.cuppy.cuttingPlanes.solve" href="#coinor.cuppy.cuttingPlanes.solve">solve</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>